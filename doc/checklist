
1. 内核态的函数中，是否有来自用户态的地址？
    内核态和用户态的地址映射不一样。
    所以在内核态使用用户态的地址时，一定要记得转换！

2. 当前堆栈在哪？

3. 当前特权级是？

4. 现在的内存布局是？ 

5. 现在是分段地址，还是页映射地址，还是物理地址？
    [1] 分段地址/逻辑地址：
    
    组成1：16-bit基址:16-bit偏移
    条件：
        1. 实模式
        2. 16-bit寄存器，16-bit数据总线，20-bit地址总线(1MB)
    20-bit线性地址 = 16-bit基址 << 4 + 16-bit偏移

    组成：16-bit选择子:32-bit偏移
    条件：
        1. 保护模式
        2. 32-bit寄存器，32-bit数据总线，32-bit地址总线(1MB) [?]
        3. 选择子：指向段描述符，描述了32-bit基址 + 20-bit界限
    32-bit线性地址 = 32-bit基址(段描述符) + 32-bit偏移(不能超过20-bit界限)

    * 若没有分页，线性地址=物理地址

    [2] 页映射地址：

    组成1：10-bit页目录索引:10-bit页表索引:12-bit偏移
    条件：
        1. PDE 中 PS位(bit7) = 0
    32-bit物理地址 = 20-bit页基址(页表项) << 12 + 12-bit偏移

    组成2：10-bit页目录索引:22-bit偏移
    条件：
        1. PDE 中 PS位(bit7) = 1
    32-bit物理地址 = 10-bit页基址(页目录项) << 22 + 22-bit偏移

    * 页目录基址记录在 CR3 寄存器(20-bit)，
      页表基址记录在页目录项(20-bit)，都是4KB对齐的
    * 分页要在保护模式下才能开启
    * 页目录项(PDE)，页表项(PTE)都为32-bit

    [3] 物理地址

6. ld 链接时，相同属性的段排列是按名字的？？？即便入口地址不符合？

7. 为什么函数都要以 push ebp; mov ebp, esp 开头呢？
    看下面这段准备调用某个函数前的汇编：
    0008:000061c0 push ebp
    0008:000061c1 mov ebp, esp
    0008:000061c3 sub esp, 0x00000018   ;这段预留空间有什么用？保护吗？对齐吗？
    0008:000061c6 mov dword ptr ss:[esp], 0x000062e5
    0008:000061cd call .+14 (0x000061e0)

    主观的说，这么做我们就记住了函数开始时堆栈的基准位置，这样会如何？
    当然是为了更方便的取参数啊！！！所有外部参数都堆在这个基准上面啊有木有！！
    有了 ebp 这个基准，即便后面使用了堆栈，esp 变化了，也能通过 ebp 
    直接定位参数。
    哲学的说，ebp 和 esp 就像 静与动，esp 在家里上窜下跳的，ebp 则稳稳守在门口，
    一个负责动态数据存储与恢复，一个负责获取外部参数，动静结合，各司其职！！

    当然，如果在函数里不打算用 push, pop 操作，则 esp 不会变，不记录基准到 ebp 也可。

8. 论 TR(task register) 的使用率，硬切换，软切换
    硬切换使用了CPU的硬件支持，每个任务一个 TSS（真的需要吗？），因为 GDT 中描述符号个数有限，限制了最大任务数量
    软切换则通过软件模拟了这个过程，所有任务共用一个 TSS，自己保存各个寄存器的值。

    不过，软切换中是否也触发了 TR 保存与恢复寄存器呢？这样不会有问题吗？

    linux-0.11 关键是 switch_to 里面的 ljmp，使用了保存在 __tmp 里的数据作为 selector:offset，
    其中 selector

    首先，切换主要是通过 jmp 或者 call 指令
    软切换 和 硬切换 区别的关键是，是否利用了 CPU 的任务切换机制
    其中，硬切换通过让 jmp, call 指向一个新 TSS 段的 selector，或者 call 一个调用门，
    以触发 CPU 的任务切换机制，（然后 CPU 就会将当前任务的寄存器一类东西
    保存到现在的 TSS，从新 TSS 那里恢复寄存器等执行状态，这里当然包含了
    堆栈切换）
    而软切换只利用了特权级变换会触发堆栈切换而已，(具体的说，从 TSS 里取 内核堆栈，
    然后将当前 ss, esp, eflags, cs, eip 依次入栈)，其它工作都需要手动，比如保存恢复寄存器
    状态。
    * 因此软切换只需使用一个 TSS (以便切换特权级时 CPU 从中获取 ss0, esp0 来切换堆栈)，
      硬切换则每个任务都要一个

9. 中断重入：OrangeOS 里中断的处理例程已经在 关中断的时候 屏蔽了同类中断，为何同类中断重入
仍然会发生？

10. 一个诡异的bug: 一个初始化为0的全局变量(int_reenter)，其值其实是未知的。
    解决办法：
        1. 在代码里显示初始化为0，
        2. 或者在编译选项里添加 -fno-common

11. 进一步理解调用约定：寄存器使用。
    对于调用者，在调用子函数后，哪些寄存器可以假定不变，哪些不可以？
    对于被调用的子函数，在返回前，必须保证哪些寄存器恢复到调用前的状态？
    详见 calling_convention.pdf

12. 汇编中的label，与c中的指针：
    label只是一个指针常量，不是一个指针变量！不占用内存，不能当作指针变量解释

13. 注意！目前的系统实现中：<= 16MB 的地址是一一映射的，即 线性地址 = 物理地址

14. 一个有趣的设计思考：orangeos 只支持时间中断一种 进程切换，但目前 RXD-OS 需要可主动
触发的进程切换，同时需要 睡眠-唤醒 机制，如何实现？
    这里涉及两个重要的新概念：
        1. 内核态抢占（相对的是，用户态抢占）
        2. 主动抢占，即调用调度函数去执行其它任务（相对的是，中断触发的被动抢占）

    目前的系统的进程切换只有一种：时钟中断触发的，用户态抢占。
    缺少：内核态抢占，主动抢占（以支持 睡眠-唤醒 机制）

-------------------------------------------------------------------------
-------------------------------------------------------------------------
boot:
相关硬件: 软盘，内存，CPU
    在软盘 FAT12 文件系统中查找 loader.bin        [软盘]
    加载 loader.bin 入内存
    向 loader 交出控制权

loader:
相关硬件: 软盘，内存，CPU
相关BIOS中断: 15h - 检测可用内存
实模式到保护模式的变化: 见Orange's P87 自己的笔记

    检测可用内存                            [BIOS中断]
    在软盘 FAT12 文件系统中查找 kernel.bin  [软盘]
    加载 kernel.bin 到内存                  [软盘，内存]
    从 real mode 跳转到 protect mode        [CPU]
    开启分页机制                            [CPU，内存（放页表）]
    整理 kernel 到内存 **                   [内存]
    向 kernel 交出控制权                    [CPU]

kernel:
相关硬件: 内存，CPU，8259A
    迁移堆栈，esp 指向 kernel 栈顶          [内存]
    迁移 gdt 表，设置 gdt 指针              [内存]
    建立 idt 表，设置 idt 指针，寄存器      [内存]
    初始化 8259A 中断控制器
    填充 idt 表（配置中断、异常处理函数、属性等）[CPU，内存]
    Game over!

有趣的问题:
1. 时钟中断是怎么工作的？
    CPU 处理时钟中断前，有两道槛：
        一、中断控制器 8259A 的 IMR(Interrupt Mask Register)，
            这个寄存器控制了 8259A 屏蔽哪些中断
        二、CPU 的 EFLAGS 寄存器中 IF 位是否开启
    首先了解一下 8259A ：
        1）它相当于一个外部中断（包括时钟中断）的代理，可以自动
            根据优先级处理中断请求
        2）我们可以设置它的 IMR 来指定屏蔽的中断
    所以，为了接收时钟中断，我们需要关闭 IMR，开启 IF。
    
    那么时钟中断来了，我们怎么处理呢？
        自然是在中断向量表 (IDT) 里为它专门提供一个处理函数

    那么，IDT里面那么多处理函数，怎么知道哪一个是处理时钟的呢？
        其实，CPU 接收中断，接收的是中断的号码，根据这个号码索引
        IDT 中的函数，并调用。
        也就是说， 8259A 接收到时钟中断后，一是向 CPU 提出中断请求，
        二是告诉 CPU 时钟中断的号码。
        那么，这个号码是固定的吗？不是的。我们可以在初始化 8259A
        的时候告诉它时钟中断对应的号码。
        所以，我们要让 IDT 和 8259A 协商好才行。

    所以，整个流程就是：
        8259A 接受到时钟中断 -> 检查 IMR 是否屏蔽 ->
        向 CPU 请求中断，并发送时钟中断的号码 ->
        CPU 检查 IF 是否开启 ->
        根据发来的号码调用 IDT 中的处理函数。

    * 那么，中断处理完了，现在 CPU 通过调用 retd 返回之前的运行
    点，那 8259A 呢？如果它不知道，它就不能接受新的中断。
        情况是，我们必须在处理结束后，发送 EOI(End of Interrupt)
        给 8259A。

    * 补充：8259A 的中断号码是连续的，我们只能设置其第一个中断的
        号码，后面的中断号码自动递增获得。
    * 补充：可屏蔽中断与不可屏蔽中断(NMI)的区别是？
            只有一个：NMI 不受 IF 位的影响。

2. ELF 文件是如何被加载进内存的？它的内存布局如何？ 

3. 目前的操作系统实现里，内核与用户进程的代码段、数据段范围定义都是重叠的，那么某段代码的 DPL 怎么决定？CPU 如何提供硬件保护？

4. 硬盘是端口读写，每条指令最多读写一个字，那为什么不需要在每次读写一个字的时候都读写一次硬盘？
    a) 因为硬盘有自己的硬件缓冲器件，叫硬盘缓冲区。
    b) 每一次读操作：
        [1] CPU 通过端口，发送读指令到硬盘
        [2] 硬盘根据指令，把数据批量读入这个硬件缓冲区。
        [3] 硬盘读完数据，触发中断。
        [4] CPU 接受到硬盘中断，开始从端口读硬盘数据。
        所以即便 CPU 通过端口一个字一个字读，也只是读这个缓冲区，而非
        每读一个字，硬盘都要执行一次机械读操作。
    c) 每一次写操作类似，CPU通过端口一个字一个字的写，其实是写到这个
    缓冲区，

    * 补充：硬盘缓冲区实际是焊接在PCB（印制电路板）上的闪存颗粒。
        一般大小在 16MB ~ 64MB。

