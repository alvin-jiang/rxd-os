系统二进制接口：
    中断、异常、系统调用的进入、退出机制
    活动进程切换机制

文件系统（VFS）：
    方案比较
        磁盘：
        1. 连续分配：简单+高效/固定的文件长度+外碎片
            非常适合 CD-ROM，DVD 等只读设备
        2. 链表分配：空间充分利用/随机访问非常慢+块逻辑变复杂
        3. 有独立链表描述的链表分配：空间充分利用+不错的随机访问速度/整个链表描述必须在内存里
            这就是 FAT 文件系统，20GB 的磁盘，FAT 大小为 60～80MB
        4. 索引节点：磁盘充分利用+消耗内存少，与磁盘大小无关
            Unix 文件系统
        *ref:操作系统设计与实现


调度系统：
    基本调度机制
    进程表
    优先级调度

    TODO:
    - 睡眠/唤醒机制

内存管理：
    分页机制

[字符设备IO]

[块设备IO] 一个足够复杂的系统！
页缓存：
    方案比较
        1. nowrite
        2. write-through
        3. write-back
磁盘与内存的映射关系管理：
    方案比较
        1. buffer_head
        2. bio
    *ref:Linux内核设计与实现
块IO代理：
    基本功能：
        1. 接受请求
        2. 调用相应驱动完成请求，并通知相关进程
    - 电梯算法
    - 缓冲
    - 错误处理
RAMDISK：
    基本功能：
        1. 初始化使用的内存
        2. 读写内存
硬盘驱动：
    基本功能：
        1. 初始化硬盘（识别、获取参数）
        2. 读写硬盘
    - 错误处理


移植：
    1. char 类型在有些架构（intel）为有符号，有些架构（ARM）为无符号
        -> 定义 schar, uchar
    2. int, long 与 指针 的大小
        -> long, 指针 与机器字长相等（push的操作尺寸）
        -> int 在16位机器占2字节，在32和64位机器占4字节
        -> 定义固定长度的类型 u8, s8, u16, s16, u32, s32, ...
    3. 时间，CPU 频率
        -> 定义相关变量 Hz
        -> 启动时设定时钟的频率
    4. 结构对齐
        -> 开编译器选项 -Wpadded

    5. 字节序 [暂时忽略]
    6. 页长度 [暂时忽略]
        -> 根据体系结构定义 PAGE_SIZE, PAGE_SHIFT
    7. 指令排序，编译器优化带来的问题，改变指令的执行顺序
       加快执行速度（某些架构下） [暂时忽略]
        -> 要么关闭优化
        -> 要么实现内存屏障机制 rmb(), wmb(), smp_rmb(), smp_wmb()
    8. SMP, 内核抢占，高端内存 [暂时忽略]
        -> 如果内核要支持SMP架构，记得正确的选择和使用锁哟
        -> 如果内核要支持内核抢占，记得正确的选择和使用锁以及内核抢占语句哟
        -> 如果内核要支持高端内存，必要时使用kmap()

    9. 大尺寸局部变量（>= 8 byte）作为返回值
        不同编译器处理不一样，完全不具备可以移植性
    10. 可变参数 va_list 的实现在 x86 和 x86_64 下的实现差别很大
    *ref:Linux内核设计与实现

编码风格：
    ...

