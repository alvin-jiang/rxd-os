TODO:
    1. 完善文件系统
    2. 调度系统（实现进程的睡眠唤醒机制)
    3. 整合IO模块（实现字符设备驱动、完善块设备驱动）
TODO-ex:
    1. 优化内存管理（slab层）
    2. 正则表达式引擎（用于文件系统的模式匹配）
    3. 文件系统安全性

系统二进制接口：
    中断、异常、系统调用的进入、退出机制
    活动进程切换机制

文件系统：
    方案比较
        磁盘：
        1. 连续分配：简单+高效/固定的文件长度+外碎片
            非常适合 CD-ROM，DVD 等只读设备
        2. 链表分配：空间充分利用/随机访问非常慢+块逻辑变复杂
        3. 有独立链表描述的链表分配：空间充分利用+不错的随机访问速度/整个链表描述必须在内存里
            这就是 FAT 文件系统，20GB 的磁盘，FAT 大小为 60～80MB
        4. 索引节点：磁盘充分利用+消耗内存少，与磁盘大小无关
            Unix 文件系统
        *ref:操作系统设计与实现
        *ref:file-system.txt


调度系统：
    基本调度机制
    进程表
    优先级调度

    TODO:
    - 睡眠/唤醒机制

内存管理：
    分页机制

    TODO:
    - 底层页管理与分配
        问题：如何从启动初始化到最初状态，最初状态是怎样的？忽略1MB，使用2-3MB？
    - slab 分配器

输入输出系统：
    [字符设备]
    [块I/O]
        外部接口：
            bread/bwrite/brelse
        高速缓冲区：
            buffer_head
            缓存写
        底层驱动统一接口：
            ll_rw_block/电梯算法/错误处理
        底层驱动：
            open/close/read/write/ioctl
            内存虚拟盘（RAMDISK）驱动、硬盘驱动
        *ref:block-device-drive.txt

移植：
    1. char 类型在有些架构（intel）为有符号，有些架构（ARM）为无符号
        -> 定义 schar, uchar
    2. int, long 与 指针 的大小
        -> long, 指针 与机器字长相等（push的操作尺寸）
        -> int 在16位机器占2字节，在32和64位机器占4字节
        -> 定义固定长度的类型 u8, s8, u16, s16, u32, s32, ...
    3. 时间，CPU 频率
        -> 定义相关变量 Hz
        -> 启动时设定时钟的频率
    4. 结构对齐
        -> 开编译器选项 -Wpadded

    5. 字节序 [暂时忽略]
    6. 页长度 [暂时忽略]
        -> 根据体系结构定义 PAGE_SIZE, PAGE_SHIFT
    7. 指令排序，编译器优化带来的问题，改变指令的执行顺序
       加快执行速度（某些架构下） [暂时忽略]
        -> 要么关闭优化
        -> 要么实现内存屏障机制 rmb(), wmb(), smp_rmb(), smp_wmb()
    8. SMP, 内核抢占，高端内存 [暂时忽略]
        -> 如果内核要支持SMP架构，记得正确的选择和使用锁哟
        -> 如果内核要支持内核抢占，记得正确的选择和使用锁以及内核抢占语句哟
        -> 如果内核要支持高端内存，必要时使用kmap()

    9. 大尺寸局部变量（>= 8 byte）作为返回值
        不同编译器处理不一样，完全不具备可以移植性
    10. 可变参数 va_list 的实现在 x86 和 x86_64 下的实现差别很大
    *ref:Linux内核设计与实现

编码风格：
    ...

